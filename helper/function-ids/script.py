import re
from bs4 import BeautifulSoup

# Load the HTML file
with open("table.html", "r", encoding="utf-8") as file:
    html_content = file.read()

# Parse the HTML
soup = BeautifulSoup(html_content, "html.parser")

# Extract all function IDs
function_map = []
for row in soup.find_all("tr"):
    cells = row.find_all("td")
    if len(cells) > 1:
        function_text = cells[0].get_text(strip=True)
        match = re.search(r'function:([\w-]+)$', function_text)
        if match:
            function_id = function_text  # Full function ID (URI)
            function_name = match.group(1)  # Extracted short name
            function_map.append((function_id, function_name))

# Convert to Rust-style PascalCase enum variants
def to_rust_enum(name):
    return re.sub(r'(^|-)([a-z])', lambda m: m.group(2).upper(), name)

rust_enum_variants = [to_rust_enum(name) for _, name in function_map]

# Generate Rust enum definition
rust_enum = """use std::str::FromStr;
use serde::{Serialize, Deserialize};
// Generated by helper/function-ids/script.py

#[allow(dead_code)] 
// During development it does not make sense to have dead code warngings here
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
pub enum Function {
    """ + ",\n    ".join(rust_enum_variants) + """
}

impl FromStr for Function {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
""" + "\n".join([f'            "{fid}" => Ok(Self::{to_rust_enum(name)}),' for fid, name in function_map]) + """
            _ => Err(()),
        }
    }
}

#[allow(dead_code)]
impl Function {
    pub fn to_xacml_id(&self) -> &'static str {
        match self {
""" + "\n".join([f'            Self::{to_rust_enum(name)} => "{fid}",' for fid, name in function_map]) + """
        }
    }
}

impl Serialize for Function {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.to_xacml_id())
    }
}

impl<'de> Deserialize<'de> for Function {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: &str = Deserialize::deserialize(deserializer)?;
        Function::from_str(s).map_err( |_| serde::de::Error::custom("invalid function URI"))
    }
}

mod test_function {
    #[cfg(test)]

    use super::*;
    use serde::{Serialize, Deserialize};
    use quick_xml::{se::to_string, de::from_str};
    
    #[derive(Serialize, Deserialize)]
    struct TestPolicy {
        #[serde(rename = "FunctionId")]
        pub function: Function,
    }

    #[test]
    fn test_function_enum_to_str_mapping() {
        let function = Function::StringEqual;
        assert_eq!(function.to_xacml_id(), "urn:oasis:names:tc:xacml:1.0:function:string-equal");
    }

    #[test]
    fn test_str_to_function_enum_mapping() {
        let function = Function::from_str("urn:oasis:names:tc:xacml:1.0:function:string-equal").unwrap();
        assert_eq!(function, Function::StringEqual);
    }

    #[test]
    fn test_serialize()
    {
        let policy = TestPolicy {
            function: Function::StringEqual,
        };
        let xml = to_string(&policy).unwrap();
        assert_eq!(xml, r#"<TestPolicy><FunctionId>urn:oasis:names:tc:xacml:1.0:function:string-equal</FunctionId></TestPolicy>"#);
    }
    
    #[test]
    fn test_deserialize()
    {
        let xml = r#"<TestPolicy><FunctionId>urn:oasis:names:tc:xacml:1.0:function:string-equal</FunctionId></TestPolicy>"#;
        let policy: TestPolicy = from_str(xml).unwrap();
        assert_eq!(policy.function, Function::StringEqual);
    }

    #[test]
    fn test_invalid_xml_deserialization() {
        let xml = r#"<TestPolicy><FunctionId>urn:oasis:names:tc:xacml:1.0:function:unknown</FunctionId></TestPolicy>"#;
        let result: Result<TestPolicy, _> = from_str(xml);
        assert!(result.is_err());
    }

}
"""

# Save to a Rust file
with open("function.rs", "w", encoding="utf-8") as rust_file:
    rust_file.write(rust_enum)

print("Rust enum with FromStr implementation successfully generated!")
